+++ 
draft = false
date = 2021-02-02T12:09:01+06:00
title = "Технология единого входа (Single Sign-On) на базе протокол OAuth 2.0 и OpenID Connect "
description = "Описание технологии единого входа (Single Sign-On) и спецификации протокол OAuth2 в разрезе использования в приложениях разрабатываемых на платформе .NET"
tags = ["sso", "OAuth2", "JWT", "Single Sign-On", "Идентификация", "Аутентификация", "Авторизация", "OpenID Connect", "IdentityServer 4", "JSON Web Token", "STS", "Security Token Service", "Сервис выдачи токенов", "Claims", "Grant Types", "Implicit flow", "Hybrid flow", "Authorization code", "Код авторизации", "Resource owner password", "Client credentials", "Device flow", "Refresh token"]
categories = ["Информационная безопасность", "Веб-разработка"]
series = ["Безопасность в веб-приложениях"]
+++

Данная статьи написана в качестве моих конспектов по изучению технологии единого входа (Single Sign-On) и спецификации протоколов OAuth2 и OpenID Connect в разрезе использования в приложениях разрабатываемых на платформе .NET

## Основные термины

Прежде всего необходимо разобраться с базовыми терминами, которые используются в области обеспечения безопасности приложений. 

### Кодирование, Шифрование, Хеширование, Запутывание
Encoding vs. Encryption vs. Hashing vs. Obfuscation

* **Кодирование** предназначено для обеспечения удобства использования данных и может быть изменено путем использования того же алгоритма, который кодировал содержимое, т.е. ключ не используется.
* **Шифрование** предназначено для сохранения конфиденциальности данных и требует использования ключа (хранящегося в секрете), чтобы вернуться в открытый текст.
* **Хеширование** предназначено для проверки целостности контента путем обнаружения всех его модификаций посредством очевидных изменений в выводе хеша.
* **Запутывание** используется, чтобы не дать людям понять смысл чего-либо, и часто используется с компьютерным кодом, чтобы помочь предотвратить успешное обратное проектирование и / или кражу функциональности продукта.

***Ссылки***
* [Encoding vs. Encryption vs. Hashing vs. Obfuscation](https://danielmiessler.com/study/encoding-encryption-hashing-obfuscation/)

### Идентификация, Афутентификация, Авторизация
Identification, Authentication, Authorization

* **Идентификация** (от латинского identifico — отождествлять): присвоение субъектам и объектам идентификатора и / или сравнение идентификатора с перечнем присвоенных идентификаторов. Например, представление человека по имени отчеству - это идентификация.
* **Аутентификация** (от греческого: αυθεντικός ; реальный или подлинный): подтверждение подлинности чего-либо или кого-либо. Например, предъявление паспорта - это подтверждение подлинности заявленного имени отчества.
* **Авторизация** является функцией определения прав доступа к ресурсам и управления этим доступом. Авторизация — это не то же самое что идентификация и аутентификация: идентификация — это называние лицом себя системе; аутентификация — это установление соответствия лица названному им идентификатору; а авторизация — предоставление этому лицу возможностей в соответствие с положенными ему правами или проверка наличия прав при попытке выполнить какое-либо действие. Например, авторизацией являются лицензии на осуществление определённой деятельности.  

***Пример***:  
```
1. Регистрация = заказ столика в ресторане;  
2. Идентификация (ввод логина) = пришёл, подходишь к администратору ресторана, говоришь я здесь заказывал столик;  
3. Аутентификация (ввод пароля) = администратор говорит — докажи что ты это ты) Ты показываешь права или паспорт;  
4. Авторизация = администратор смотрит в список гостей и говорит — ваш вон тот столик у параши;  
```

***Ссылки***
- [Идентификация, аутентификация, авторизация — в чем разница?](http://it-uroki.ru/uroki/bezopasnost/identifikaciya-autentifikaciya-avtorizaciya.html)
- [Аутентификация и авторизация в микросервисных приложениях](https://habr.com/ru/company/dataart/blog/311376/)

### Single Sign-On (SSO) 
**Single Sign-On (SSO)** — технология единого входа — позволяет пользователю переключаться между различными приложениями без повторной аутентификации. Используя SSO можно избежать множественных логинов, так что пользователь просто не будет замечать этих переключений. При этом ситуации, когда в рамках вашей инфраструктуры таких приложений будет больше одного, встречаются постоянно. Технология единого входа особенно удобна в больших энтерпрайз-системах, состоящих из десятков приложений, слабо связанных между собой. Вряд ли пользователи будут довольны, вводя логин и пароль при каждом обращении к системе учета рабочего времени, корпоративному форуму или внутренней базе документов.

Или говоря другими словами, пользователь аутентифицируется один раз в SSO, и в дальнейшем авторизуется в различных приложениях с помощью этих аутентификационных данных. Централизованный сервис аутентификации.

**SSO** обеспечивает пользователя **токеном**, с помощью которого он позднее сможет взаимодействовать с различными API и другими приложениями по протоколам **OAuth 2.0** и **OpenID Connect**. 

**Протокол** - это свод правил и стандартов.  
Использование протоколов [OpenID Connect](https://openid.net/specs/openid-connect-core-1_0.html) и [OAuth 2.0](https://tools.ietf.org/html/rfc6749) в купе с [JSON Web Token (JWT)](https://tools.ietf.org/html/rfc7523) является наиболее востребованным на текущий момент способом обеспечения безопасности приложений. 

![Основные протоколы обеспечения безопасности приложений](/images/sso/ru/security_protocols.jpg)

***Ссылки***
* [JSON Web Token (JWT)](jwt)
* [OAuth 2.0](aouth2)
* [OpenID Connect](open_id_connect)
* [Authentication vs. Federation vs. SSO](https://medium.com/@robert.broeckelmann/authentication-vs-federation-vs-sso-9586b06b1380)

### Авторизация приложения, авторизация пользователя
**Application Authorization** vs **User Authorization**.  

Необходимо разделять аутентификацию/авторизацию стороннего приложения, и аутентификацию/авторизацию пользователя, это разные процессы, имеющие разную цель.  

За аутентификацию/авторизацию стороннего приложения отвечает протокол **OAuth2**.  
За аутентификацию/авторизацию пользователя отвечает протокол **OpenID Connect**.  

По правилам протокола OAuth2, SSO - аутентифицирует и авторизует сторонные приложение для доступа к ресурсам других сторонних приложений.  
По правилам, описанным в спецификации протокола OpenID Connect, SSO авторизует пользователя для приложения, т.е. использует OAuth 
2.0 для того, чтобы представить параметры профиля польозователя так, как будто это ресурсы стороннего приложения.

## JSON Web Token (JWT)

**JSON Web Token (JWT)** — это JSON объект, который определен в открытом стандарте [RFC 7519](https://tools.ietf.org/html/rfc7519). Он считается одним из безопасных способов передачи информации между двумя участниками. Для его создания необходимо определить ***заголовок*** (**header**) с общей информацией по токену, ***полезные данные*** (**payload**), такие как id пользователя, его роль и т.д. и ***подписи*** (**signature**).
Правильно JWT произносится как /dʒɒt/.

Простыми словами, JWT — это лишь строка в следующем формате `header.payload.signature`.  

### Структура токена

![Структура токена](/images/sso/ru/structure_token.png)

### Основные поля токена

Кратко остановимся на том, какие есть стандартные полях в токене и зачем они нужны:

* **iss** — адрес или имя удостоверяющего центра.
* **sub** — идентификатор пользователя. Уникальный в рамках удостоверяющего центра, как минимум.
* **aud** — имя клиента для которого токен выпущен.
* **exp** — срок действия токена.
* **nbf** — время, начиная с которого может быть использован (не раньше чем).
* **iat** — время выдачи токена.
* **jti** — уникальный идентификатор токен (нужен, чтобы нельзя был «выпустить» токен второй раз).

### Процесс аутентификации с помощью JWT 
Предположим, что мы хотим зарегестрироваться на сайте. В нашем случае есть три участника — пользователь **user**, сервер приложения **application server** и сервер аутентификации **authentication server**. Сервер аутентификации будет обеспечивать пользователя токеном, с помощью которого он позднее сможет взаимодействовать с приложением.  

![JWT процесс аутентификации](/images/sso/ru/jwt.jpg)

***Ссылки***
* [Расшифровка JWT - jwt.io](https://jwt.io/)

## OAuth 2 и OpenID Connect 

Предварительно, необходимо ознакомится с основными терминами протоколов OAuth2 и Open ID Connect.

### Базовые понятия протоколов OAuth 2 и OpenID Connect
#### Сервис выдачи токенов (Security Token Service - STS)

**Security Token Service** — важнейший объект всей конструкции централизованного сервиса аутентификации, он также может называться Open ID Connect Provider, Identity Provider authorization server, IdentityServer, Авторизационный сервер и т. д. Различные источники называют его по-разному, но по смыслу это сервис, который выдает токены клиентам.

***Основные функции***:
* Аутентифицировать пользователей, используя внутреннее хранилище пользователей или внешний источник (например, Active Directory).
Управлять клиентами (хранить) и аутентифицировать их.  
* Предоставлять управление сессией и возможность реализации Single sing-on.  
* Выдавать identity-токены и access-токены клиентам.  
* Проверять ранее выданные токены.  

#### Клиент (Client)

**Client** — устройство или программа (браузер, приложение), которым требуется либо токен для аутентификации пользователя, либо токен для доступа к какому-то ресурсу (подразумевается, что данный ресурс «знаком» с тем конкретным «Security Token Service» у которого клиент запрашивает токен для доступа).

#### Пользователь (User)

**User** — собственно конечный пользователь — человек. User Resource Owner.

#### Область действия (Scope)

**Scope** — идентификатор ресурса, к которому клиент хочет получить доступ. Список scope посылается в адрес сервиса выдачи токенов в составе запроса на аутентификацию.

По умолчанию все клиенты имеют возможность запрашивать любые области, но это можно (и нужно) ограничивать в конфигурации сервиса выдачи токенов.

Scopes бывают двух видов:

* **Identity scopes** — это запрос информации о пользователе. Его имя, профиль, пол, фотография, адрес электронной почты и т. д.  
* **Resource scopes** — имена внешних ресурсо (Web APIs), к которым клиент хочет получить доступ.

#### Идентификационные данные (Claims)
Claims - это идентификационные данные определяющие личность, например, имя или адрес электронной почты, или роль и т.д.  

Идентификационные данные (Claims) зависят от области действия (Scope). 
Подробнее о Claims рассказано ниже, в секции, где рассматривается Open ID Connect

#### Запрос на аутентификацию (Authentication/Token Request)

**Authentication/Token Request** — процесс запроса аутентификации.

В зависимости от того какие области (***scopes***) запрошены, сервис выдачи токенов вернет:
Только ***Identity Token***, если запрошены только **Identity scopes**.
***Identity Token*** и ***Access Token***, если запрошены также и **Resources scopes**.
***Access Token*** и ***Refresh Token***, если запрошeн **Offline Access**.

#### Токен личности (идентификации) (Identity Token)

**Identity Token** — подтверждение аутентификации. Этот токен содержит минимальный набор информации о пользователе.

#### Токен доступа (Access Token)

**Access Token** — информация, что конкретному пользователю разрешается делать. Клиент запрашивает Access Token и затем использует его для доступа к ресурсам (Web APIs). Access Token содержит информацию о клиенте и пользователе, если она присутствует. Важно понимать, что есть такие типы авторизации, при которых пользователь в процессе непосредственно не участвует (подробнее об этом в следующей части)

#### Токен обновления (Refresh Token)

**Refresh Token** — токен, по которому STS вернет новый Access Token. В зависимости от режима работы, Refresh Token может быть многоразовым и одноразовым. В случае с одноразовым токеном, при запросе нового Access Token будет также сформирован готовый Refresh Token, который следует использовать при повторном обновлении. Очевидно, что одноразовые токены более безопасны.  
Cхема Refresh Token + Access Token ограничивает время, на которое атакующий может получить доступ к сервису. По сравнению с одним токеном, которым злоумышленник может пользоваться неделями и никто об этом не узнает.

**Ссылки**
* [Зачем нужен Refresh Token, если есть Access Token?](https://habr.com/ru/company/voximplant/blog/323160/)

### Процесс аутентификации

![Процесс аутентификациие](/images/sso/ru/authprocess.png)
При обращении пользователя к клиенту, тот перенаправляет пользователя на **Open ID Connect Provider**, который запрашивает у пользователя логин и пароль. В случае успешного прохождения проверки параметров аутентификации он возвращает назад **identity token** и **access token**, с которыми пользователь может обращаться к защищенному ресурсу.

### Тип разрешения на авторизацию (Grant Types)
**Grant Types** - это способ указать, как клиент хочет взаимодействовать с SSO. Еще можно назвать "Варианты взаимодействия" клиента с Авторизационным Сервером. 

Спецификации OpenID Connect и OAuth 2 определяют следующие варианты взаимодействия:
**OAuth 2.0 Grant Types**:
* [Implicit (Неявный поток авторизации)](#implicit-нееявный-поток-авторизации)
* [Authorization code (Код авторизации)](#authorization-code-код-авторизации)
* [Resource owner password (Пароль владельца ресурса)](#hybrid-гибридный)
* [Client credentials (Учетные данные клиента)](#resource-owner-password-пароль-владельца-ресурса)
* [Device flow (Поток устройства)](#client-credentials-учетные-данные-клиента)
* [Refresh Token (Обновление токенов)](#device-flow-поток-устройства)

IdentityServer 4 реализует OAuth 2.0 grant types, и добавляет свои. 
**Специфичные для IdentityServer Grant Types**:
* Hybrid (Гибридный)
* Extension grants (Расширение грантов)

***Ссылки***
* [OAuth 2.0 Grant Types](https://oauth.net/2/grant-types/)

## OAuth 2.0
Абстрактное описание протокола OAuth 2.0  
![Абстрактное описание протокола OAuth 2.0](/images/sso/ru/abstract-protocol-flow-russian.png)
1. Приложение запрашивает у пользователя авторизацию на доступ к серверу ресурсов.  
2. Если пользователь авторизует запрос, приложение получает разрешение на авторизацию (authorization grant).  
3. Приложение запрашивает авторизационный токен у сервера авторизации (API) путём предоставления информации о самом себе и разрешении на авторизацию от пользователя.  
4. Если подлинность приложения подтверждена и разрешение на авторизацию действительно, сервер авторизации (API) создаёт токен доступа для приложения. Процесс авторизации завершён.  
5. Приложение запрашивает ресурс у сервера ресурсов (API), предоставляя при этом токен доступа для аутентификации.  
6. Если токен действителен, сервер ресурсов (API) предоставляет запрашиваемый ресурс приложению.  
Фактический порядок шагов описанного процесса может отличаться в зависимости от используемого типа разрешения на авторизацию, но в целом процесс будет выглядеть описанным образом. Далее мы рассмотрим различные типы разрешений на авторизацию.

Порядок событий в типичном потоке.
1. Пользователь (User) запрашивает через Клиента (Client) доступ к ресурсам (методам) какого-нибудь API.
2. API смотрит, авторизован ли пользователь, путем проверки наличия токенов. 
3. Если токен отсутствует, то Пользователь редикетится на SSO (IdentityServer), где проходит аутентификацию Пользователя. И в случае успеха предоставляет Клиенту токен.
4. С полученным токеном Клиент запрашивает повторно ресурс API и прикладывает к запросу токен.
5. API проверяету SSO валидность токена, и в случае успеха, предоставляет пользователю ресурс. 

На диаграме ниже, показаны шаги 3-5.  
![Концептуальная схема работы протокола OAuth2](/images/sso/ru/oauth2.png)

***Ссылки***
* [Введение в OAuth 2.0](https://www.digitalocean.com/community/tutorials/oauth-2-ru)

## Open ID Connect
Основные элементы Open ID Connect:  

![Основные элементы Open ID Connect](/images/sso/ru/openidconnect.png)

- **Standard Claims** -openid, profile, email, adress, phone
- **Methods** - метод для запроса более детальых клеймов
- **ID Token** - собственно информация о пользователе
- **UserInfo Endpoint** - информация о пользователе

Все стандартные области действия (Scopes) и их соответствующие идентификационные данные (Claims) можно найти в [спецификации OpenID Connect](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims).

## Описание типов взаимодействия (Grant Types)

### Схема выбора варианта вазимодействиия:
**Еще раз. Как выбрать Grant Type?**

- MVC app - Hybrid or Implict
- Desktop (host browser) - Autorization Code
- SPA or any JS app - Implicit
- Mobile - Authorization Code with PKCE
- Sever to server integration - Client credentials

![Схема выбора варианта вазимодействиия](/images/sso/ru/select_granttype.png)

***Ссылки***
* [A Guide To OAuth 2.0 Grants](https://alexbilbie.com/guide-to-oauth-2-grants/) - еще один способ сделать выбор.

### Implicit (Нееявный поток авторизации)
Для современных SPA и JS приложений  
![Неявный поток авторизации](/images/sso/ru/implict_flow.png)

В сложной микросервисной архитектуре, в случае, если используется проходы между микросервисами от имени пользователя, не рекомендуется использовать. Так как при цепочке взаимодействия микросервисов друг с другом может протухнуть токен, при незавершенном процессе обработки запроса. В таких случаях рекомендуется использовать вариант Hybrid

**Проблемы неявного потока авторизации**:  
- Access token недоступен на сервере
- Токен живет не долго (минуты-часы)

### Authorization code (Код авторизации)
Поток кода авторизации изначально был задан в OAuth 2 и обеспечивает способ получения токенов по обратному каналу, а не по переднему каналу браузера. Он также поддерживает аутентификацию клиента. Хотя этот тип гранта поддерживается сам по себе, обычно рекомендуется объединять его с ***токенами идентификации***, которые превращают его в так называемый гибридный поток (Hybrid flow).  
Hybrid flow gives you important extra features like signed protocol responses.  
![Поток кода авторизации](/images/sso/ru/authorization-code-flow-russian.png) 

### Hybrid (Гибридный)
В данном потоке авторизации, на небезопасном клиенте получается Авторизационный код, который затем передается на сервер (бакенд), который уже в безопасной среде получит acess_token и refresh_token, для доступа к собственным и сторонним (микро)сервисам. 
![Гибридный поток авторизации](/images/sso/ru/hybrid_flow.png)  

### Resource owner password (Пароль владельца ресурса)
"Классический сценарий" - вход по логину и паролю, не рекомендуется. Устаревший способ. 
![Поток авторизации пароля владельца ресурса](/images/sso/ru/resource_owner_grant_flow.png)  

**Проблемы потока авторизации пароля владельца ресурса (resource owner grant)**:
- Это вообще не аутентификация
- Риск утечки пароля
- Риск утечки refresh token
- Нет поддержки Federated Identity

### Client credentials (Учетные данные клиента)
Server to server integration:  
![Поток авторизации учетных данных клиента](/images/sso/ru/client_credentials_flow.png)  

**Проблемы потока авторизации учетных данных клиента**:
- Это вообще не аутентификация
- Риск утечки пароля
- Риск утечки refresh token
- Нет поддержки Federated Identity
- Нет пользователя 

### Device flow (Поток устройства)
Поток авторизации устройств предназначен для устройств без браузера или устройств с ограниченным вводом, где пользователь не может безопасно свои учетные данные. Этот поток делает аутсортинг аутентификации пользователя и оптравляет запрос на согласие на внешнее устройство (например, смартфон). Этот поток обычно используется устройствами IoT и может запрашивать как ресурсы идентификации, так и ресурсы API.  
![Поток авторизации устрйоства](/images/sso/ru/device_flow.png)   

***Ссылки***  
- [OAuth 2.0 Device Flow Grant](https://alexbilbie.com/2016/04/oauth-2-device-flow-grant/)

## IdentityServer 4
Это промежуточное ПО, реализация протоколов OAuth2 и OpenID Connect для .Net Core. Является одним из ключевых компонентов **SSO**.  
![IdentityServer 4](/images/sso/ru/identityserver.jpg)

**Ссылки по IdentityServer 4**
* [Официальная документация по IdentityServer 4](http://docs.identityserver.io/en/latest/)
* [Репозиторий исходного кода IdentityServer](https://github.com/IdentityServer/IdentityServer4)
* [Официальная страница IdentityServer](https://identityserver.io/)
* Видео 
    * [Построение SSO на примере Identity Server 4.0 (.NET Core 2.0)](https://www.youtube.com/watch?v=6Y7Glw6NzLM)
    * [IdentityServer4 на практике](https://www.youtube.com/watch?v=Gw3Wryvv6Rg)
* Статьи  
    * [Имплементация OpenId Connect в ASP.NET Core при помощи IdentityServer4 и oidc-client (Implict flow)](https://habr.com/ru/post/337784/)
    * [User Authentication and Identity with Angular, Asp.Net Core and IdentityServer (Implict flow)](https://fullstackmark.com/post/21/user-authentication-and-identity-with-angular-aspnet-core-and-identityserver)
* Примеры
    * [Policy-based authorization for web API using JWT and identityserver4 and Asp.Net Core 2](https://github.com/HamidMosalla/OAuth2-OpenIDConnect-JWT-Samples)
* Шаблоны
    * [skoruba/IdentityServer4.Admin](https://github.com/skoruba/IdentityServer4.Admin) - Готовый шаблон реализации SSO, с UI пользователя и администратора. 