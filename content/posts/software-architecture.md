+++ 
draft = true
date = 2021-02-05T11:46:49+06:00
title = "Основы архитектуры приложений"
description = "Основы архитектуры приложений, с учетом их разработки на платформе .NET"
tags = ["программаня архитектура", "dotnet"]
categories = ["Архитектура приложений"]
series = ["Программная инженерия"]
+++

Данная статьи написана в качестве моих конспектов по изучению архитекутры приложений, и представляет из себя компиляцию из различных источников, представленную в виде краткого путеводителя по архитектуре приложений, с учетом их разработки на платформе .NET.

## Вводная часть
### Что такое архитектура ПО

Архитектура приложения, архитектура кода.
https://www.youtube.com/watch?v=0XOpY01OouM

https://www.ibm.com/developerworks/ru/library/eeles/index.html

Задача архитектуры - управлять сложностью. И это те  решения, которые нельзя изменить.

Архитектурное решение - это общий подход к решению поставленной задачи, который описывает как и что должно решаться. 
Архитектурные представления (перспективы) - это взглдя на какую-либо проблему с разных точек зрения. 

Каждое архитектурное представление может быть выполнено в том или ином стиле, или комбинировать несколько стилей одновременно. 

Архитектурное представление может для решения проблемы использовать какой-нибдуь архитектурный шаблон, который может быть основан на каком-нибдуь архитектурном стиле.  

Архитектурный стиль например - это клиентсерверная архитектура, пайп подход, микроядерная архитектура, или плагинная, компонентный подход. 
Архитектурный стиль может выступать как в роли архитектурного шаблона, так и в роли архитектурного решения. 

Архитектурный шаблон - это воспроизводимое решение, которое может использоваться из проекта в проект. 

Не все архитектурные шаблоны являются архитектурными стилями. Например MVC - это архитектурный шаблон, но не стиль. 
Архитектурный стиль - набор признаков, которые характеризуют подход к решениюю проблемы в рамках архитектурной перспективы. 

Архитектурный стиль может использоваться как и архитектурное решение. Например бывает архитектурный стиль - трехуровневый, и бывает трехуровневое архитектурное решение. 

В разных архитектурных перспективах можно использовать разные архитектурные стили. 

![Что такое архитектура ПО](/images/software-architecture/ru/001_about.png)  

### Для чего?
- Каждый инженер должен быть хотя бы на 30% архитектором;
- Понимание всхе компонентов системы и их связей веден к снижению рисков на проекте и повышению цены специалиста на рынке;
- Расширение кругозора приводит к более правильным локальным и глобальным  техническим решениям. 

### Основные архитектурные драйверы
Что влияет в большей степени на архитектуру приложений:
- Влияние процесса разработки и команды клиента;
- Нефункциональные требования:
    - Аттрибуты качества системы;
    - Лицензии на ПО, которые уже есть у клиента; 
    - Инфраструктура клиента;
- Функциональные требования.

### Аспекты работы архитектора приложений 
- **Solution architect** - как философия, определяющая методологию разработки, структуру команд, комопненты системы и их связи; 
- **Teach Lead** - как реализация конкретного модуля, выбор локальных средств и координация с глобальной структурой;
- **Software designer** - как дизайн бизнес-домена в рамках архитектуры приложения.

## Технический долг

**Технический долг** (также известный как долг кодинга) — это метафора программной инженерии, обозначающая накопленные в программном коде или архитектуре проблемы, связанные с пренебрежением к качеству при разработке программного обеспечения и вызывающие дополнительные затраты труда в будущем. Технический долг обычно незаметен для конечных пользователей продукта, а связан с недостатками в сопровождаемости, тестируемости, понятности, модифицируемости, переносимости. По аналогии с финансовым долгом, технический долг может обрастать «процентами» — усложнением (или даже невозможностью) продолжения разработки, дополнительным временем, которое разработчики потратят на изменение программного продукта, исправление ошибок, сопровождение и т. п. Хотя увеличение технического долга как правило негативно влияет на будущее проекта, оно может быть и сознательным, компромиссным решением, продиктованным сложившимися обстоятельствами.

Сам по себе плохой код не всегда является техническим долгом, так как ущерб ("проценты по долгу") появляются из-за необходимости изменения кода со временем.

Термин технический долг используется в первую очередь по отношению к разработке программного обеспечения, но он также может быть применён и к другим сферам проектирования.

Иногда термин используется неправильно, обозначая более не поддерживаемый код (англ. legacy code), который является некачественным и написанный кем-то другим.

## Типы программных архитектур

{TODO": Разобраться с типами архитектур и дать им определния, и наприсовать диаграммы, плюсы и минусы}

[P2P системы](https://ru.bmstu.wiki/P2P_(Peer-to-Peer))

Можно выделить два основных типа программных архитектур:
- Клиент-серверная архитектура
- 2p2

Микроядерная, пайп, реактивная

Типы клииент-серверной архитектуры 
- Монолитная
- Распределенная

Еще бывают Звенья (уровни архитекутры)
https://sergeygavaga.gitbooks.io/kurs-lektsii-testirovanie-programnogo-obespecheni/content/lektsiya-6-ch1-arhitektura-klient-server.html
http://www.myshared.ru/slide/817557/

Архитектурный стиль, архитектурный шаблон, архитектурное решение.

## N-слойная архитектура
![N-слойная архитектура](/images/software-architecture/ru/006_nlayer.png)  
{TODO: Описать n-слойную архитектуру}

## Сервисо-ориентированная архитектура
![Сервисо-ориентированная архитектура (SOA)](/images/software-architecture/ru/007_soa.png)  
{TODO: Описать сервис-ориентированную архитектуру}

## Микросервисная архитектура
![Микросервисная архитектура](/images/software-architecture/ru/008_mircoservices.png)  
![Микросервисная архитектура](/images/software-architecture/ru/microservices.jpeg)  

{TODO: Описать микросервисную архитектуру}
https://proglib.io/p/monolitnaya-vs-mikroservisnaya-arhitektura-2019-09-16
https://hawkhouse.ru/blog/kogda-opravdano-ispolzovanie-mikroservisnoj-arhitektury/

## Эволюция корпоративных решений
Корпоративные решения эволюционируют с потребностями компании.
При разработке - акцент на экономическую часть - быстрый ROI, особенно для растущей компании.
**Эволюция архитектуры систем**
Монолит  -> Монолит с ограниченными контекстами -> Сервис-ориентированная архитектура -> Микросервисная архитектура

**Эволюция инфраструктуры**
Локальыне виртуальные машины -> Облачные решения

## Эволюционные риски монолитной системы
Основной риск - система может превратиться в "большой комок грязи", "слипшихся макарон", "спагетти". Это является следствием следующих проблем:
- Сильная связанность;
- Циклические зависимости;
- Плохо разделенные ответственности 

![Большой комок грязи](/images/software-architecture/ru/big-ball-of-mud.png) 
 

## Типичные требования к корпоративной системе
Ниже перечислены типичные требования к корпоративной системе:
- Необходимость согласованности данных;
- Устойчивость к сбоям и потерям данных;
- Объемы данных в тысячи/десятки/сотни тысяч записей;
- Требования к производительности - умеренные, пару секунд подождем

**Функциональность**:
- Документооборот;
- Простроение отчетов;
- Обработка, модификация и представление корпоративных данных;
- Доступ десятков-сотен пользователей;

## Принципы проектирования

12 факторов для при разработке SaaS - https://12factor.net/ru/

### YAGNI
**You Aren't Gonna Need It** - вам это не понадобится.
Основная проблема, которую решает принцип YAGNI — это устранение тяги программистов к излишней абстракции, к экспериментам «из интереса» и к реализации функционала, который сейчас не нужен, но, по мнению разработчика, может либо вскоре понадобиться, либо просто будет полезен, хотя в реальности такого очень часто не происходит.
«Бесплатных» функций в программных продуктах просто не бывает. YAGNI применяется для ограждения проектов от «размывания» их рамок.

При нарушении:  
- Ненужная сложность (оверинженеринг) 
- Быстрее накапливается [Технический Долг](#технический-долг)  

### KISS
![KISS](/images/ru/011_kiss.png)  

### DRY
DRY – Don’t repeat yourself - не повторяй себя.
![DRY](/images/ru/013_dry.png)  

### SOLID
![SOLID](/images/ru/014_solid.png)  
L - Наследующий класс должен дополнять, а не замещать поведение базового класса

### Domain Driven Design
![Domain Driven Design](/images/ru/015_ddd.png)  
**Domain-Specific Language**, **DSL** - Предметно-ориентированный язык  

**Паттерны DDD:**
- [Domain Driven Design на практике](https://habr.com/ru/post/334126/)  
- [Список паттернов DDD](https://habr.com/ru/post/61524/)  
- [Domain-Driven Design: стратегическое проектирование. Часть 1](https://habr.com/ru/post/316438/)  
- [Domain-Driven Design: тактическое проектирование. Часть 2](https://habr.com/ru/post/316890/)  
